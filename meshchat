#!/usr/bin/ruby
# Mesh Chat Client 1.0 (meshchat-1.0)
# Copyright(c) 2011 by Christopher Abad
# mailto:aempirei@gmail.com
# aim:goim?screenname=ambient+empire
# http://www.twentygoto10.com
# git://github.com/aempirei/Mesh-Chat-Client.git

require 'rubygems'
require 'getoptlong'
require 'socket'
require 'etc'
require 'readline'

PROGRAM = 'Mesh Chat Client'
VERSION = '1.0'
ARG0 = File.basename(__FILE__)

#
# the user class, which represents all the data on other users that can be collected
#

class User
	attr_accessor :username
   attr_accessor :visible
   attr_accessor :online
   attr_accessor :idle
   attr_accessor :age
   attr_accessor :distance
   attr_accessor :friend
   attr_accessor :friend_request
end

#
# the MeshChat class should be a singleton class at $mesh which contains all the client state
#

class MeshChat

	DFLSERVER = '127.0.0.1'
	DFLPORT = 30201

	attr_accessor :server
	attr_accessor :port

	attr_reader :socket
	attr_reader :servername
	attr_reader :motd
	attr_reader :users
   attr_reader :width
   attr_reader :height
   attr_reader :lines

	def initialize
		@server = DFLSERVER
		@port = DFLPORT
      @users = []
      @width, @height = screensize
      @lines = []
	end

   def startup

      # register at_exit

      Kernel.at_exit do
         puts "executing exit proceedure"
         @socket.close unless @socket.nil?
      end

      # connect socket

      @socket.close unless @socket.nil?

      begin
         @socket = TCPSocket.open($mesh.server, $mesh.port)
      rescue Exception => e
         puts "caught exception " + e.to_s 	
         exit
      end

      # register SIGINT handler

      Kernel.trap('INT') do |signo|
         Kernel.trap(signo, 'SIG_IGN')
         puts "captured interrupt, exiting"
         exit
      end

      return true
   end

   def readline_ready?
      return true
   end

   def socket_ready?
      return ( not @socket.nil? )
   end

   def gotoxy(x,y)
      printf("\33[%d;%dH", y + 1, x + 1)
   end

   def clreol
      print "\33[2K"
   end

   def clrscr
      print "\33[2J"
   end

   def pushpos
      print "\33[s"
   end

   def poppos
      print "\33[u"
   end

   def screensize

      # this way sucks, but oh well

      return [ `tput cols`.to_i, `tput lines`.to_i ]
   end

   def do_readline

      line = Readline.readline("\33[#{@height};1H> ", true)

      return if(line.nil? or line.empty?)

      if(line =~ /^\/(\w+)(?:\s+(.*))?$/)

         command = $1.upcase
         data = ($2.nil? ? '' : ' ' + $2)
         @socket.print(command + ' ' + data + "\n")

      else
         @socket.print('SAY :' + line + "\n")
      end

   end

   def do_socket

      line = @socket.gets
      
      return if line.nil?

      line.chop!

      if(line =~ /^@\s+(\w+)\s+(\d+)\s+([^:]*)(?:\s+:(.*))?$/)

         msg = sprintf("USERNAME: %s DISTANCE: %d ACTION: %s MESSAGE: %s\n", $1, $2.to_i, $3, $4)

      elsif(line =~ /^(\d{3})\s+([^:]*)(?:\s+:(.*))?$/)

         msg = sprintf("CODE: %s PARAMS: %s MSG: %s\n", $1, $2, $3)

      else

         msg = sprintf("UNKNOWN LINE: %s\n", line)

      end

      @lines << msg

      pushpos

      range = 0...(@height - 1)

      range.each do |lineno|
         gotoxy(0, @height - 1 - lineno)
         clreol
         print @lines[-lineno].slice(0,@width) if not @lines[-lineno].nil?
      end

      poppos


   end

end

$mesh = MeshChat.new

#
# command-line options definition block
#

OPTIONS = [
	[ [ '--server' , '-s', GetoptLong::REQUIRED_ARGUMENT ], :server, 'server address' ],
	[ [ '--port'   , '-p', GetoptLong::REQUIRED_ARGUMENT ], :port  , 'server port'    ],
	[ [ '--help'   , '-h', GetoptLong::NO_ARGUMENT       ], nil    , 'help'           ],
	[ [ '--version', '-V', GetoptLong::NO_ARGUMENT       ], nil    , 'version'        ]
]

#
# the usage function which prints out the usage when --help is invoked
#

def usage

	width = 20

	print "\n"
	
	version()

	print "\nusage: " + ARG0 + " [options]\n\n"

	OPTIONS.each do |option,arg,desc|

		( long, short, params ) = option
		
		str = [ long, short ].compact.join(', ') + ' '
		str += arg.to_s.upcase unless arg.nil?

		printf("\t%-*s%s", width, str, desc)
		printf(' (default: %s)', $mesh.send(arg)) unless arg.nil?
		print "\n"
	end

	print "\n"

end

#
# the version function which prints the client version when --version or --help is invoked
#

def version
	puts PROGRAM + ' ' + VERSION
end

#
# proccess the command-line options
#

opts = GetoptLong.new(*OPTIONS.map { |x| x.first })

opts.each do |opt,arg|
	case opt
		when '--server'
			$mesh.server = arg
		when '--port'
			$mesh.port = arg
		when '--help'
			usage()
			exit
		when '--version'
			version()
			exit
	end
end

#
# make socket connection -- this client is pretty basic
#

$mesh.startup

tl = Thread.new do
   until $mesh.socket.closed?
      if $mesh.socket_ready?
         $mesh.do_socket
      end
   end
end

until $mesh.socket.closed?
   if $mesh.readline_ready?
      $mesh.do_readline
   end
end
